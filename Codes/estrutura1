Slide 1 capa
Slide 2

A queue √© uma das estruturas de dados fundamentais da ci√™ncia da computa√ß√£o.

Queue(Fila) √© um exemplo de uma estrutura de dados FIFO.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A estrutura de dados da fila garante que voc√™ saia na ordem em que voc√™ entrou na fila. Por exemplo, se um elemento foi inserido na estrutura de dados da fila, ele teria que esperar at√© alcan√ßar a frente da fila antes de poder ser removido.

Se voc√™ est√° esperando na fila para uma refei√ß√£o, voc√™ ficaria naturalmente chateado se algu√©m decidir cortar.

O conceito descrito no par√°grafo anterior √© conhecido como FIFO, e √© um conceito universal que n√£o √© usado apenas em ci√™ncia da computa√ß√£o. Por exemplo, o FIFO √© usado em campos como contabilidade.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 3

O que √© uma estrutura de dados FIFO?
FIFO significa first in, first out.

Woah isso soa t√£o t√©cnico!

Acredite, √© um conceito ridiculamente f√°cil de entender e entender.

FIFO significa apenas que os itens saem da fila na ordem em que entram. O primeiro elemento inserido √© o primeiro a sair da fila.

Por outro lado, o √∫ltimo elemento adicionado √† fila √© o √∫ltimo elemento a sair da fila. Se mais itens forem adicionados, esses itens se tornar√£o os √∫ltimos a sair.

Uma estrutura de dados FIFO √© aquela em que os dados s√£o acessados e removidos na ordem em que foram inseridos.

O oposto do FIFO √© o LIFO, que significa √∫ltimo a entrar, primeiro a sair.

Um excelente exemplo de uma estrutura de dados que utiliza a abordagem LIFO √© a estrutura de dados da pilha.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 4 Exemplo no mundo real

Imagine que voc√™ est√° na fila para pegar um √¥nibus, bonde ou assistir a um filme.

Voc√™ √© atualmente a quinta pessoa na fila. Isso significa que voc√™ ser√° capaz de seguir as primeiras quatro pessoas na sua frente.

Voc√™ ter√° que esperar at√© que a pessoa na sua frente tenha obtido o.

Da mesma forma, a pessoa √† sua frente, tamb√©m deve esperar at√© que a pessoa na frente deles prossiga para embarcar.

√â aqui que voc√™ pega a frase

Senhor, por favor, espere na fila at√© a sua vez!

Os itens na fila s√£o desenfileirados na ordem em que entram na fila. Direito justo? Ningu√©m gosta de pessoas que cortam, especialmente quando elas t√™m que esperar muito tempo para chegar perto da frente da fila.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 5 Casos de uso pr√°tico na programa√ß√£o

Agora que entendemos conceitualmente a estrutura de dados da fila, vamos dar uma olhada em alguns casos de uso na programa√ß√£o.

A fila √© usada para manipular um trabalho ou dados na ordem em que eles ocorrem.

Por exemplo, digamos que estamos coletando dados de um dispositivo que est√° enviando pacotes de dados consistentemente por meio do protocolo TCP / IP. E, de repente, a conex√£o fica inst√°vel por 10 segundos. Os dados que n√£o foram enviados devido √† perda de conex√£o podem ser armazenados em uma fila, de modo que quando a conex√£o √© estabelecida ap√≥s 10 segundos, ela dispara o pacote na ordem de ocorr√™ncia e n√£o em alguma ordem aleat√≥ria. Dessa forma, o registro de data e hora para cada pacote de dados estar√° em ordem cronol√≥gica.

Outros exemplos em que a estrutura de dados da fila seria ideal incluem

* Job scheduling(Agendamento de trabalho) - Queremos executar cada trabalho na ordem em que eles ocorrem.
* Network handing (Manipula√ß√£o de rede) - queremos atender os usu√°rios na ordem em que eles acessam o servidor. Por exemplo. Usu√°rios esperando na fila pelo suporte t√©cnico em um site de hospedagem como bluehost.com

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
apenas cita√ß√£o dado abstrato

A fila √© um tipo de dado abstrato, o que significa que √© um tipo de dado definido por seus comportamentos.

*** pesquisar dados abstratos ***

Enquanto nossa implementa√ß√£o aderir semanticamente √† defini√ß√£o da estrutura de dados da fila, estamos livres para implement√°-la como desejarmos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 6 Varia√ß√µes da Queue

Apart from the basic queue implementation, there are also variations and they are

* Deque (double-ended queue). Not to be confused with the dequeue operation.
* Circular queue.

In double ended queues, we can insert and delete from the front and the back. In other words, you get the best of both the FIFO and LIFO world, but at the cost of additional memory.

In circular queues, the first element is connected to the last element to make that circular shape.

I smell pointers ‚Ä¶

By now, hopefully, it is making sense to you that implementing the queue data structure using linked lists might be more appropriate.

Doing the queue array implementation, however, will work those muscles out and really make sure that the queue concept sticks to you like super glue.

Don‚Äôt worry. In a future post, we will be implementing the queue data structure using linked lists.

******************************************************************************
Al√©m da implementa√ß√£o b√°sica da fila, tamb√©m existem varia√ß√µes e s√£o

* Deque (fila dupla). N√£o deve ser confundido com a opera√ß√£o de desenfileiramento.
* Fila circular.

Nas filas de espera dupla, podemos inserir e excluir da frente e de tr√°s. Em outras palavras, voc√™ obt√©m o melhor do mundo FIFO e LIFO, mas ao custo da mem√≥ria adicional.

Em filas circulares, o primeiro elemento √© conectado ao √∫ltimo elemento para fazer essa forma circular.


Agora, esperamos que esteja fazendo sentido para voc√™ que implementar a estrutura de dados da fila usando listas encadeadas seja mais apropriado.

Fazer a implementa√ß√£o da matriz de filas, no entanto, ir√° trabalhar esses m√∫sculos para fora e realmente se certificar de que o conceito de fila gruda em voc√™ como super-cola.

N√£o se preocupe. Em uma postagem futura, estaremos implementando a estrutura de dados da fila usando listas encadeadas.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 7 Implementa√ß√£o da Queue na Estrutura de Dados

There are multiple ways of implementing the queue data structure. In this tutorial, we will be using the two most common methods. We can implement the queue using the

* Array or the
* Linked list

as the underlying data structure.

The underlying data structure is simply the data structure that is used to store the variables behind the scene. For example, in the linked list, the underlying data structure will be nodes. Please do note that arrays can also be used as underlying data structure for both the queue and linked list.

In the same way, we can also use the linked list or nodes as the underlying data structure for the queue.

This involves setting the head as the first item of the queue. We are only able to interact with the head. The head only has a pointer to the next node.

For your education, using the linked list as the underlying data structure is recommended. I will mention this many times to drill this into your head, because it it so important.

More often than not, the linked list is the preferred underlying data structure for implementing the queue, because array need to be constantly resized.

If you don‚Äôt know what a linked list is, I recommend reading an introduction to the linked list before proceeding.

Why do arrays need to be resized? Because they are static data structures, meaning they are fixed in size upon creation. If the collection becomes too large for the array to hold, we need to create a new array and copy the contents over.

******************************************************************************
Existem v√°rias maneiras de implementar a estrutura de dados da fila. Neste tutorial, usaremos os dois m√©todos mais comuns. Podemos implementar a fila usando o

* Matriz ou o
* Lista vinculada

como a estrutura de dados subjacente.

A estrutura de dados subjacente √© simplesmente a estrutura de dados usada para armazenar as vari√°veis ‚Äã‚Äãpor tr√°s da cena. Por exemplo, na lista vinculada, a estrutura de dados subjacente ser√° n√≥s. Observe que as matrizes tamb√©m podem ser usadas como estrutura de dados subjacente para a fila e a lista vinculada.

Da mesma forma, tamb√©m podemos usar a lista ou os n√≥s vinculados como a estrutura de dados subjacente para a fila.

Isso envolve definir a cabe√ßa como o primeiro item da fila. N√≥s s√≥ somos capazes de interagir com a cabe√ßa. A cabe√ßa s√≥ tem um ponteiro para o pr√≥ximo n√≥.

Para sua educa√ß√£o, √© recomend√°vel usar a lista vinculada como estrutura de dados subjacente. Vou mencionar isso muitas vezes para perfurar isso em sua cabe√ßa, porque √© t√£o importante.

Na maioria das vezes, a lista vinculada √© a estrutura de dados subjacente preferencial para implementar a fila, porque a matriz precisa ser constantemente redimensionada.

Se voc√™ n√£o sabe o que √© uma lista vinculada, recomendo ler uma introdu√ß√£o √† lista vinculada antes de continuar.

Por que os arrays precisam ser redimensionados? Porque s√£o estruturas de dados est√°ticas, o que significa que elas s√£o fixas em tamanho na cria√ß√£o. Se a cole√ß√£o se tornar muito grande para a matriz ser mantida, precisamos criar uma nova matriz e copiar o conte√∫do.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 8 Interface da Queue

For us to implement the queue, we need a basic interface. The basic queue should have the following methods.

* enqueue(T data): Add an item to the end of the queue. Remember, you need to wait in line until it is your turn. No cutting in line okay? üôÇ
* dequeue(): Not to be confused with deque (double-ended queue), dequeue removes the first element from the queue. In certain implementations, the item that was removed is also returned.
* front(): Get the first element of the queue without removing it.
* size(): Get the size of the queue.
* isEmpty(): Returns true if list is empty. Otherwise, return false.
For the sake of being able to view what is in the queue, we will also be implementing a print() method to print out the items inside of the queue.

******************************************************************************
Para implementarmos a fila, precisamos de uma interface b√°sica. A fila b√°sica deve ter os seguintes m√©todos.

* enfileiramento (dados T): adiciona um item ao final da fila. Lembre-se, voc√™ precisa esperar na fila at√© que seja a sua vez. Nenhum corte na linha est√° bem? üôÇ
* dequeue (): N√£o deve ser confundido com deque (fila dupla), o dequeue remove o primeiro elemento da fila. Em determinadas implementa√ß√µes, o item que foi removido tamb√©m √© retornado.
* front (): obt√©m o primeiro elemento da fila sem remov√™-lo.
* size (): Obt√©m o tamanho da fila.
* isEmpty (): Retorna verdadeiro se a lista estiver vazia. Caso contr√°rio, retorne falso.
Para poder ver o que est√° na fila, tamb√©m estaremos implementando um m√©todo print () para imprimir os itens dentro da fila.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 9 Implementa√ß√£o de Array na Queue

As mentioned in a previous section, we will begin investigating how to implement the queue data structure using the array implementation.

We are going to be using our brain, so put on your thinking caps.

In the array implementation, the front index or the reference variable that keeps track of the first item (the first non-null item) of the array.

Because the array is a static data structure, we won‚Äôt be able to reduce the size of the array at run time. Instead, we will set the deleted elements to null and increment the front index.

.......

******************************************************************************
Como mencionado em uma se√ß√£o anterior, come√ßaremos a investigar como implementar a estrutura de dados da fila usando a implementa√ß√£o da matriz.

N√≥s vamos usar nosso c√©rebro, ent√£o coloque em seus limites de pensamento.

Na implementa√ß√£o da matriz, o √≠ndice frontal ou a vari√°vel de refer√™ncia que controla o primeiro item (o primeiro item n√£o nulo) da matriz.

Como a matriz √© uma estrutura de dados est√°tica, n√£o podemos reduzir o tamanho da matriz em tempo de execu√ß√£o. Em vez disso, definiremos os elementos exclu√≠dos como nulos e incrementaremos o √≠ndice frontal.
.......
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 10 M√©todos da Estrutura de Dados Queue

******************************************************************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 11 M√©todo Enqueue

******************************************************************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 12 M√©todo Dequeue

******************************************************************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 13 M√©todo Front

******************************************************************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Slide 14 Aumentando dinamicamente o tamanho da Queue 


